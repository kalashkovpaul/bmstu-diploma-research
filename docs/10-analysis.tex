\section{Аналитическая часть} \label{analysis}

В данном разделе будут рассмотрены принципы работы с гипертекстовыми документами согласно объектной модели документа и виртуальной объектной модели документа.

\subsection{Гипертекстовые документы}

Гипертекстовым~\cite{hypertext} документом является документ, состоящий из текстовых страниц, имеющих перекрёстные ссылки.
В данной работе под гипертекстовыми документами будут подразумеваться документы, написанные при помощи языка гипертекстовой разметки (англ. \textit{HyperText Markup Language} --- HTML)~\cite{html}, а именно документы, соблюдающие стандарт HTML5~\cite{html-doc}.


Данный выбор обусловлен тем, что использование HTML5 получило широкое распространение в Всемирной сети~\cite{internet} благодаря рекомендации~\cite{html-recommendation} к использованию от Консорциума Всемирной паутины (англ. \textit{World Wide Web \newline Consortium} --- W3C)~\cite{w3c}.
Вследствие данной рекомендации HTML документы поддерживают большинство самых распространённых браузеров в России, такие, как Google Chrome, Яндекс.Браузер, Microsoft Edge, Opera и Firefox~\cite{browser-popularity-russia}.

\subsection{Web-приложение}

Web-приложение (англ. \textit{Web application})~\cite{web-application-definition}  --- web-страница (HTML или её вариант и CSS) или набор web-страниц, доставляемых про протоколу HTTP, которые используют обработку на стороне сервера или клиента (например, \linebreak JavaScript) для обеспечения прикладного взаимодействия в браузере.

Web-приложения отличаются от простого web-контента наличием интерактивных элементов.

\subsection{Существующие алгоритмы обновления гипертекстового документа}

Из самых используемых фреймворков для разработки web-приложений на июнь 2023 года~\cite{web-frameworks-statistics} можно выделить шесть, предоставляющих готовые решения в области обновления гипертекстовых документов: React (JavaScript), Angular (JavaScript), Vue.js (JavaScript), Flask (Python), Django (Python), Svelte (JavaScript). 

В задаче отображения страницы можно выделить три следующие стадии:
\begin{enumerate}[label=\arabic*)]
	\item подготовка HTML содержимого страницы;
	\item построение объектной модели документа по HTML страницы;
	\item отображение объектной модели документа на экран.
\end{enumerate}

В данной работе рассматриваются алгоритмы, относящиеся к последним двум стадиям, т.~е. построению и отображению DOM.
Из-за этого будут рассмотрены готовые  решения, относящиеся к этим двум стадиям.

Алгоритмы этих готовых решений можно разделить на две крупных категории: алгоритмы, использующие объектную модель документа и алгоритмы, использующие виртуальную объектную модель документа.
Рассмотрим подробнее каждую из этих категорий.

\subsection{Алгоритмы, использующие объектную модель  документа}

Объектная модель документа (англ. \textit{Document Object Model} --- DOM)~\cite{dom} --- программный интерфейс для HTML, XML и CSV документов.
Он обеспечивает структурированное представление документа в виде дерева~\cite{balanced-tree}, и определяет способ, по которому структура может быть доступна для программы, для изменения структуры документа, его стиля и содержания.
Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы.

Стадарт W3C DOM~\cite{dom-doc} формирует основы DOM, реализованные в большинстве современных браузеров.
Для описания структуры DOM потребуются следующие термины: корневой, родительские и дочерние элементы.
Корневой элемент находится в основании всей структуры и не имеет родительского элемента.
Дочерние элементы не просто находятся внутри родительских, но и наследуют различные свойства от них.
Рассмотрим, как выглядит DOM-представление HTML документа, представленного на листинге \ref{code:simple}.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример простого HTML документа}
	\label{code:simple}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/simple.html}
\end{code}

Корневым элементом здесь является \codeword{html}, он не имеет родительского элемента и имеет два дочерних --- \codeword{head} и \codeword{body}. По отношению друг к другу элементы \codeword{head} и \codeword{body} являются сиблингами (братьями и сестрами). В каждый из них можно вложить еще много дочерних элементов. Например, в \codeword{head} обычно находятся \codeword{link}, \codeword{meta}, \codeword{script} или \codeword{title}.

Данный HTML документ будет иметь следующее DOM-представление, изображённое на рисунке \ref{fig:simple-dom-1}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=130mm]{img/simple-dom-1.png}
	\caption{Пример DOM-представления для простого HTML документа}
	\label{fig:simple-dom-1}
\end{figure}

Все эти теги не являются уникальными, и в одном документе может быть по несколько экземпляров каждого из них.

В \codeword{body} могут находиться разнообразные элементы.
Например, в родительском \codeword{body} --- дочерний элемент \codeword{header}, в элементе \codeword{header} --- дочерний элемент \codeword{section}, в родительском \codeword{section} --- дочерний \codeword{div}, в \codeword{div} --- элемент \codeword{h3}, и, наконец, в \codeword{h3} — элемент \codeword{span}.
В этом случае \codeword{span} не имеет дочерних элементов, но их можно добавить в любой момент.
Пример того, как можно описать добавление данных элементов, представлен на рисунке \ref{fig:simple-dom-2}.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=120mm]{img/simple-dom-2.png}
	\caption{Пример DOM-представления для чуть более сложного HTML документа}
	\label{fig:simple-dom-2}
\end{figure}

%Пример, при котором система была бы более разветвлённая и с большим количеством вложений, представлен на рисунке \ref{fig:complicated-dom}.
%
%\begin{figure}[h]
%	\centering
%	\includegraphics[width=170mm]{img/complicated-dom.png}
%	\caption{Пример DOM-представления для сложного HTML документа}
%	\label{fig:complicated-dom}
%\end{figure}
%
%На схеме изображено довольно большое DOM-дерево, и его сложно воспринимать из-за его размера.
%Для удобства часто используется система многоуровневых списков.
%Пример того, как предыдущее дерево можно преобразовать в такой список, представлен на рисунке \ref{fig:complicated-dom-list}.
%
%\begin{figure}[h]
%	\centering
%	\captionsetup{justification=centering}
%	\includegraphics[width=115mm]{img/complicated-dom-list.png}
%	\caption{Пример DOM-представления для сложного HTML документа в виде списка}
%	\label{fig:complicated-dom-list}
%\end{figure}
%
%\clearpage

Элементы могут наследовать не все, но многие свойства своих родителей --- например, цвет, шрифт, видимость, размеры и~т.~д.

Таким образом, чтобы задать стиль шрифта на всей странице, потребуется не прописывать цвет для каждого элемента, а задать его только для \codeword{body}.
А чтобы изменить наследуемое свойство у дочернего элемента, нужно прописать только ему новые свойства.
Наследование удобно для создания единообразной страницы.
DOM-узлы содержат гораздо больше информации, чем просто данные о дочерних узлах \cite{dom-element}.
Они также содержат информацию о родительском узле, стилях, обработчиках событий и свойствах элемента, его исходном  коде и~т.~д.
В таких браузерах, как Google Chrome, DOM-дерево страницы можно посмотреть, например, при помощи инструментов разработчика \cite{devtools}.

%\subsubsection{Алгоритм построения документа с использованием  DOM}
%
%Рассмотрим алгоритм построения DOM-дерева по имеющемуся HTML документу.
%
%Для того, чтобы построить дерево объектной модели, требуется обработать документ и произвести операцию вставки в получающееся дерево $n$ раз, где $n$ - количество элементов.

\subsubsection{Обновления документа с использованием DOM}

Обновление структуры DOM --- распространённая и часто используемая операция, производимая, например, в случае, когда документ должен меняться в ответ на действия пользователя (любая активность на странице).

Рекоммендация W3C в таком случае призывает повторно отрисовать обновлённое дерево с нуля --- то есть, каждый раз, когда необходимо обновить дерево, будет использоваться алгоритм отображения~\cite{reflow}: DOM-дерево строится заново и производится операция вставки элемента $n$ раз, где $n$ - количество элементов.

Благодаря тому, что современные браузеры реализуют DOM и предоставляют API для взаимодействия с DOM-деревом, фреймворки, такие, как Angular, используют именно этот API в своих готовых решениях \cite{angular}. 

%\subsection{Алгоритмы, использующие рендеринг на стороне сервера}
%
%Рендеринг на стороне сервера (англ. \textit{Server Side Rendering} --- SSR) --- метод разработки программного обеспечения в web-приложении, которое обрабатывает запросы от пользователя на сервере, который исполняет алгоритмы в соответствии с потребностями бизнеса, отправляя пользователю ответ как результат работы почти со всем процессом рендеринга~\cite{ssr}.
%
%SSR подразумевает, что при обращении к web-странице пользователь получает HTML страницу, работающую согласно одному из HTML стандартов. В данной работе алгоритмы, использующие SSR, не будут рассмотрены подробно, поскольку использование SSR помогает ускорить загрузку страниц, но не обновление их содержимого~\cite{ssr}, алгоритм обновления эквивалентен алгоритму обновления, использующему объектную модель документа, рассмотренную выше. 
%
%Таким образом, при обновлении гипертекстовых документов с использованием SSR используется рекомендованный W3C алгоритм обновления с использованием DOM, поэтому имеет смысл рассматривать именно алгоритм обнвления с использованием DOM.

\subsection{Алгоритмы, использующие виртуальную объектную модель документа}

Основной проблемой DOM является то, что он никогда не был приспособлен для динамического интерфейса~\cite{not-dynamic}.
Он предоставляет удобный программный интерфейс, позволяющий взаимодействовать с ним из кода, но это не решает проблем с производительностью.
Современные социальные сети, такие, как ВКонтакте, Twitter или Facebook будут использовать тысячи DOM узлов, взаимодействие с которыми может занимать ощутимое для пользователя время, в то время как создатели браузера Google Chrome, к примеру, рекомендуют~\cite{dom-max} не использовать в одной странице более 800 узлов.

Одним из решений данной проблемы служит технология виртуальной объектной модели, которая, хоть  и не является стандартом, позволяет по-прежнему взаимодействовать с DOM, но делать это как можно реже.

Виртуальная объектная модель документа (англ. \textit{Virtual Document Object Model} --- VDOM)~\cite{vdom} ---  концепт программирования, в которой идеальное (<<виртуальное>>) представление пользовательского интерфейса хранится в памяти и синхронизуется с <<настоящим>> DOM при помощи алгоритмов согласования.

Вместо того, чтобы работать с DOM напрямую, согласно концепции\break VDOM работа происходит с его легковесной копией, хранящийся непосредственно в памяти компьютера.
За счёт этого операции вставки, сравнения, удаления и обхода узлов дерева происходит быстрее благодаря отсутствию необходимости отрисовывать изменения после каждой операции.

Когда в пользовательский интерфейс добавляются новые элементы, создаётся виртуальная модель DOM, представленная в виде дерева.
Если состояние любого из элементов изменяется, создаётся новое виртуальное дерево DOM.
Затем это дерево сравнивается с предыдущим виртуальным деревом.


Рассмотрим, как для простого  HTML документа, представленного на листинге \ref{code:dom-to-vdom-html}, осуществляется представление DOM- (рисунок \ref{fig:dom-to-vdom-dom}) и VDOM-дерева (листинг \ref{code:dom-to-vdom-vdom}).

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Простой HTML документ}
	\label{code:dom-to-vdom-html}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/dom-to-vdom.html}
\end{code}

\begin{figure}[h]
	\centering
	\includegraphics[width=140mm]{img/dom-to-vdom-dom.png}
	\caption{DOM-дерево для простого HTML документа}
	\label{fig:dom-to-vdom-dom}
\end{figure}

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{VDOM-дерево для простого HTML документа}
	\label{code:dom-to-vdom-vdom}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/dom-to-vdom-vdom.js}
\end{code}

Данный пример служит лишь для демонстрации того, как может осуществляться представление VDOM.
Реальные деревья содержат намного большее число узлов~\cite{dom-element}, а элементы DOM имеют гораздо больше полей (классы, идентификаторы, стили, обработчики событий, поля данных, типы и значения, вспомогательные поля и~т.~п.), и тем не менее содержат гораздо меньше информации, чем узлы DOM за счёт того, что нет необходимости хранить данные, помогающие визуализировать элемент (за это отвечает DOM).

Существует несколько способов использовать VDOM для оптимизации алгоритма отображения гипертекстового документа. с использованием алгоритма согласования и с использованием Fiber алгоритма.

\subsubsection{Обновление документа с использованием VDOM и алгоритма согласования}

Если состояние любого из элементов необходимо изменить, создаётся новое виртуальное дерево.
Затем получившееся дерево сравнивается с предыдущим виртуальным деревом объектной модели документа и происходит вычисления наилучшего из возможных методов внесения изменений в реальной DOM.
Это гарантирует минимальное количество операций с реальной DOM, что приводит к снижении стоимости обновления реальной модели.

На рисунке \ref{fig:vdom-example} показано виртуальное дерево DOM и процесс сравнения.

\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=130mm]{img/vdom-example.png}
	\caption{Пример работы алгоритма обновления документа при помощи VDOM}
	\label{fig:vdom-example}
\end{figure}

Красными кружками обозначены узлы, которые изменились --- эти узлы представляют собой элементы пользовательского интерфейса, состояние котоых изменилось.
Затем вычисляется разница между предыдущей версией\break VDOM-дерева и текущей (посредством алгоритма согласования), после чего всё родительское поддерево повторно визуализируется для получения обновлённого пользовательского интерфейса.

\subsubsubsection{Алгоритм согласования}

Алгоритм согласования (англ. \textit{reconciliation})~\cite{reconciliation} --- эвристический алгоритм решения проблемы трансформации одного дерева в другое за минимальное число операций.
Он основан на следующих двух предположениях:

Во-первых, два элемента с разными типами произведут разные деревья.

Во-вторых, можно указать, какие дочерние элементы могут оставаться стабильными между разными отображениями при помощи специального параметра \codeword{key}.

При сравнении двух деревьев первым делом производится сравнение родительских элементов, начиная с корневого.
Дальнейшее поведение различается в зависимости от типов родительских элементов.

Всякий раз, когда родительские элементы имеют различные типы, старое VDOM-дерево уничтожается и с нуля строится новое.
Так, переходы от \codeword{<div>} к \codeword{<a>} или от \codeword{<img>} к \codeword{<div>} приведут к полному перестроению дерева, старое DOM-дерево также уничтожается.

Любые элементы, лежащие ниже родительского, будут уничтожены, а их состояние уничтожится.
На листиге \ref{code:reconciliation-diff-types} приведён пример изменения узла, при котором меняется его тип и всё поддерево уничтожается.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов разного типа, при сравнении которых деревья будут полностью перестроены}
	\label{code:reconciliation-diff-types}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-diff-types.html}
\end{code}

При сравнении DOM-элементов одного типа, алгоритм согласования проверяет их атрибуты, сохраняет лежащий в основе элементов DOM-узел и обновляет только изменённые атрибуты (пример таких элементов приведён на листинге \ref{code:reconciliation-same-types}).

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов одного типа, при сравнении которых будет сохранена лишь разница содержимого атрибутов}
	\label{code:reconciliation-same-types}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-same-types.html}
\end{code}

При рекурсивном обходе дочерних элементов DOM-узла алгоритм согласования проходит по спискам потомков одновременно и находит отличие.
Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает хорошо, определяя минимальный набор операций.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в конец дочернего}
	\label{code:reconciliation-add-to-end}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-end.html}
\end{code}

Алгоритм согласования сравнит два дерева \codeword{<li>первый</li>}, сравнит два дерева \codeword{<li>второй</li>}, а затем вставит дерево \codeword{<li>третий</li>}.

При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно. Например, преобразование между этими деревьями работает плохо, минимальный набор операций для преобразованя одного дерева в другое не будет найден.

Алгоритм согласования будет преобразовывать каждого потомка, вместо того, чтобы оставить элементы \codeword{<li>Санкт-Петербург</li>} и \linebreak
\codeword{<li>Москва</li> }. Пример таких узлов продемонстрирован на листинге  \ref{code:reconciliation-add-to-start}.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в начало дочернего}
	\label{code:reconciliation-add-to-start}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-start.html}
\end{code}

Для решения этой проблемы существуют вспомогательные атрибуты \codeword{key} --- ключи~\cite{keys}. Когда у дочерних элементов есть ключи, алгоритм согласования использует их, чтобы сопоставить потомков исходного виртуального дерева с потомками полученного виртуального дерева.

Значение атрибута \codeword{key} при этом должно быть уникальным.
Так, как значение ключа  можно использовать уникальный идентификатор элемента, если он есть, или же можно добавить новое свойство идентификатора или прохешировать данные, чтобы сгенерировать ключ.
Достаточно, чтобы ключ элемента был уникальным среди его соседей, а не глобально.

Например, если добавить \codeword{key} к примеру выше, преобразование дерева будет верным.
\newline

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-узлов при добавлении элемента в начало дочернего с использованием ключей}
	\label{code:reconciliation-add-to-start-keys}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/reconciliation-add-to-start-keys.html}
\end{code}

Алгоритм согласования является эвристическим~\cite{euristic} алгоритмом, и если предположения, на которых он основан, не соблюдены, пострадает производительность.

Так, алгоритм не будет пытаться сопоставить поддеревья элементов разных типов, а ключи должны быть стабильными (например, ключ, произведённый случайно, не является стабильным), предсказуемым и уникальным.
Нестабильные ключи вызовут необязательное пересоздание многих экземпляров элемента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних элементов.


\subsubsection{Обновление документа с использованием Fiber алгоритма}

Fiber --- основной алгоритм сравнения библиотеки React, начиная с 16 версии конкурирующий с алгоритмом согласования~\cite{fiber}. Для пользовательского интерфейса не важно, чтобы каждое обновление было применено сразу; фактически такое поведение будет лишним, оно будет способствовать падению количества кадров в секунду и ухудшению пользовательского опыта~\cite{react-dive}. 

Волокно (англ. \textit{fiber}) --- объект, являющийся абстракцией работы, которую необходимо выполнить~\cite{react-dive}. Работой являются любые вычисления, которые должны быть выполнены для того, чтобы определить, какие объекты необходимо обновлять, а какие можно оставить в прежнем состоянии. Такая работа должна иметь возможность быть остановленной и возобновлённой. Рассмотрим следующий пример: пусть имеются HTML-элементы, представленные на листинге \ref{code:fiber-1}.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Пример HTML-элементов для демонстрации структуры волокна}
	\label{code:fiber-1}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/fiber-1.html}
\end{code}

Волокно, отвечающее за вычисления, связанные с кнопкой, имеющий класс btn, будет иметь следующий вид, представленный на листинге \ref{code:fiber-1-js}.

\begin{code}
	\captionsetup{justification=raggedright,singlelinecheck=off,margin=4mm}
	\captionof{listing}{Fiber объект для элемента кнопки}
	\label{code:fiber-1-js}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/fiber-1.js}
\end{code}

Поля объекта, представленного на листинге \ref{code:fiber-1-js}, имеют следующий смысл:
\begin{enumerate}[label=\arabic*)]
	\item stateNode --- указатель на объект DOM-дерева, соответствующего элементу волокна (в данном случае кнопке);
	\item child --- указатель на волокно первого дочернего элемента (в данном случае дочерних элементов нет);
	\item return --- указатель на волокно родительского элемента (в данном слечае список);
	\item sibling --- указатель на первый соседний элемент (в данном случае элемент div);
	\item props --- объект, хранящий вспомогательные свойства элемента (в данном случае, класс элемента);
	\item changed --- флаг, изменяющийся при всплытии события, инициирующего изменение (в данном случае изменение появилось не в данном элементе);
	\item tag --- флаг, отмечающий данный элемент как требующий обновления (в данном случае элемент не требует обновления).
\end{enumerate}

В процессе работы алгоритма строится два дерева fiber объектов: дерево, соответствующее текущему состоянию элементов на странице (назовём его current) и дерево, в котором производятся вычисления при обновлении (назовём его workInProgress). 
При обновлении происходит разделение вычислений на две фазы: фаза рендера (англ. \textit{render phase}), выполняемая при  помощи функции requestIdleCallback и фаза закрепления (англ. \textit{commit phase}), переносящая изменения в DOM (см. рисунок \ref{fig:render-commit-phases}). 
\begin{figure}[h]
	\centering
	\captionsetup{justification=centering}
	\includegraphics[width=170mm]{img/render-commit-phases.png}
	\caption{Связь фаз рендера и закрепления в алгоритме Fiber}
	\label{fig:render-commit-phases}
\end{figure}

Прежде, чем рассмотреть подробнее каждую из двух фаз, необходимо познакомиться с функцией requestIdleCallback и тем, как она должна работать согласно предложению W3C от 28 июня 2022 года~\cite{requestidlecallback}.

\subsubsubsection{Функция requestIdleCallback}

requestIdleCallback --- функция, впервые представленная в черновом варианте~\cite{requestidlecallback-old} W3C 17 сентября 2015 года и предназначенная для предоставления разработчикам возможности использовать периоды простоя браузера для выполнения фоновой и низкоприоритетной работы. 
10 октября 2017 года данная функция приобрела статус официально рекомендованной для реализации фунции благодаря выходу соответствующей рекомендации W3C~\cite{requestidlecallback-recommended}, поэтому сейчас она реализована такими браузерами, как Google Chrome, Microsoft Edge, Firefox и Opera~\cite{requestidlecallback-mdn}, т.~е. самыми популярными браузерами в России~\cite{browser-popularity-russia}.

Данная функция имеет один обязательный параметр callback --- ссылка на функцию, которая должна быть вызвана в ближайшем будущем, когда цикл событий будет в режиме ожидания. 
Функции callback при вызове передаётся объект, позволяющий ей при помощи вызова функции timeRemaining определить, сколько времени цикл событий будет в режиме ожидания, т.~е. когда необходимо вернуть управление циклу основных событий~\cite{requestidlecallback-time-remaining}.

Функция requestIdleCallback также имеет один опциональный параметр options, который позволяет задать значение timeout для браузера.
Если timeout задан и и имеет положительное значение, а callback ещё не был вызван по времени наступления миллисекундного timeout, callback будет вызван в течение следующего периода простоя, даже если это может привести к негативному влиянию на производительность~\cite{requestidlecallback-mdn}.

Возвращает requestIdleCallback значение идентификатора, который, будучи переданным в функцию cancelIdleCallback, позволит отменить вызов функции callback~\cite{requestidlecallback-recommended}.


\subsubsubsection{Фаза рендера}
Фаза рендера (англ. \textit{render phase}) алгоритма Fiber предназначена для определения необходимых для обновления документа операций в фоновом режиме, таки образом, чтобы работу можно было выполнять во время простоя браузера при помощи функции requestIdleCallback. Цель данной фазы --- привести workInProgress дерево fiber-элементов в целостное состояние,~т.~е. такое состояние, которое можно отобразить на web-страницы без нарушения целостности внешнего вида страницы.

Во время фазы рендера используются две функции: beginWork и\linebreak completeWork. beginWork принимает на вход текущий элемент в workInProgress дереве, после чего проверяет, необходимо ли данному элементу обновление. В случае, если оно необходимо, поле tag соответствующего текущему fiber-элемента устанавливается равным 1, и возвращается следующий элемент \linebreak workInProgress дерева, подлежащий обработке (дочерний, или, если дочерние элементы обработаны, соседний).

Функция completeWork принимает на вход current дерево fiber-элеметов, workInProgress дерево fiber-элементов и current, текущий элемент workInProgress дерева. Она проверяет значение поля tag и, если оно установлено, осуществляет рендеринг элемента current в памяти (иными словами, создаёт необходимые DOM-элементы и хранит их в памяти, не отображая их на web-странице и не внося изменений в гипертекстовый документ). После чего, если ещё существуют элементы, подлежащие рендеру, возвращается fiber-элемент для первого такого элемента (дочернего, или, если дочерние элементы отрисованы, соседнего).

\subsubsubsection{Фаза закрепления}

Фаза закрепления (англ. \textit{commit phase}) предназначена для изменения гипертекстового документа и переноса созданных в фазе рендера DOM-элементов в текущее DOM-дерево с использованием предаставленного браузером API.
В фазе закрепления не производится дополнительных вычислений, связанных с тем, необходимо менять элемент или нет.
Вместо этого осуществляется обход workInProgress дерева Fiber-элементов и происходит отображение DOM-элементов.

Отметим, что основное отличие фазы закрепления от фазы рендера заключается в том, что она должна быть выполнена от начала до конца, без прерываний. Это необходимо для соблюдения целостности внешнего вида web-страницы: при передаче управления основному циклу событий возможны изменения внешнего вида web-страницы, расходящиеся с произведёнными в фазе рендера вычислениями. Фаза рендера же не выполняется от начала до конца, вычисления происходят лишь в время, указанное функцией requestIdleCallback.

\subsubsection{Сравнение алгоритмов с использованием VDOM}

Сравним два рассмотренных выше алгоритма: алгоритм с использованием согласования и Fiber-алгоритм. Обновление документа с использованием алгоритма соогласования осуществляется от начала до конца, что может быть рассмотренно и как преимущество, и как недостаток. Как преимущество, потому что несмотря на пользовательские вычисления (т.~е. вычисления в основном цикле событий) обновление документа будет произведено в сооответствии с обусловленной эвристикой. Пользовательские вычисления будут произведены лишь после исполнения алгоритма согласования, что гарантирует корректное обновление документа.

Тем не менее, в случае, когда изменений на странице много~\cite{react-dive}, они могут занимать время, большее чем 1 кадр (при частоте обновления экрана 60 раз в секунду 1 кадр должен занимать не более, чем 16.67 миллисекунд). Такая задержка приводит к тому, что изображение обновляется ''скачками'', теряет плавность или даже приводит к переходу web-страницы в состояния, приводящие к ошибкам~\cite{fiber}. 

 Данная проблема решается переходом от алгоритма согласования к Fiber-алгоритму, согласно которому преимущественная часть вычислений осуществляется во время между обновлением кадров на экране~\cite{requestidlecallback}. 
Несмотря на это отсутствует информация о том, какой из этих алгоритмов является наиболее эффективным с точки зрения вычисления.
Чтобы ответить на этот вопрос, необходимо рассмотреть схемы изученных алгоритмов и оценить их трудоёмкость, что позволят оценить эффективность использования алгоритмов как с точки зрения пользовательского опыта и плавности изображения, так и с точки зрения производительности.

\subsection{Критерии сравнения алгоритмов обновления гипертекстовых документов}

В данной работе осуществляется сравнение изученных выше алгоритмов по трём критериям: пользовательский опыт, трудоёмкость алгоритма и затраты по памяти. Рассмотрим каждый из этих критериев подробнее.

Пользовательский опыт (англ. \textit{User Experience} --- UI) --- критерий, основывающийся на ощущениях пользователя от использования конкретноого продукта~\cite{ui-definition}. Эмпатичный подход (англ. \textit{empathic approach}) --- способ оценки пользовательского опыта, берущий за основу эмоциональный опыт человека. Данный подход позволяет, при наличии информации о необходимостях, желаниях и мотавициях человека оценить пользовательские ощущения, что позволяет разрабатывать идеи и продукты, удоволетворяющие желаниям пользователя. Отметим, что выбор пользовательского опыта от использования алгоритмов как критерия для сравнения обусловлен тем, что количественные характерики, необходимые для оценки плавности изображения при работе алгоритма (например, количество кадров в секунду), не были измерены и зафиксированы в достоверных источниках, а произвести измерения в данной работе не представляется возможным. Тем не менее, существует возможность оценить трудоёмкость изученных алгооритмов.

Трудоёмкость алгоритма --- количество операций, использованных в алгоритме для решения поставленной задачи~\cite{model}. Используется при наличии формализованной модели вычислений и формального описания алгоритма.

Затраты по памяти --- зависимость необходимой для работы алгоритма памяти. Разделяют такие виды затрат по памяти, как память входа, память выхода и дополнительная память --- именно по данным видам памяти необходимо сравнить изученные алгоритмы.

\subsection*{Вывод}

В данном разделе были рассмотрены существующие методы обновления гипертекстовых документов: алгоритмы, использующие объектную модель документа, рендеринг на стороне сервера и алгоритмы, использующие виртуальную объектную модель документа.
Как один из алгоритмов, использующих \linebreak VDOM, был рассмотрен алгоритм согласования, находящий минимальный набор операций, необходимых для преобразования одного дерева в другое.
Также был рассмотрен Fiber алгоритм и изучены две его составляющие: фаза рендера и фаза закрепления.
В соответствии с поставленной целью, необходимо разработать алгоритмы обновления документа с использованием DOM и VDOM, а также алгоритма согласования и Fiber-алгоритма.

На вход алгоритма обновления с использованием DOM будут подаваться обрабатываемый элемент, изменяемый элемент и элемент, который нужно отрисовать вместо него.
На вход алгоритма обновления документа с использованием VDOM будут подаваться корни старого VDOM-дерева и нового VDOM-дерева, а на вход алгоритма согласования - обрабатываемые узлы старого и нового VDOM-деревьев, а также указатели на массивы изменений узлов и поддеревьев.
На вход Fiber-алгоритма будут подаваться корни текущего Fiber-дерева и workInProgress-дерева.